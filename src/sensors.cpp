// Generated by Copilot
#include "sensors.h"
#include <Wire.h>
#include <MPU6050_light.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Global Sensor Objects and State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MPU6050 mpu(Wire);

// âšª NOTE: Baseline accelerometer values established during calibration
float accelBaselineX = 0.0f;
float accelBaselineY = 0.0f;
float accelBaselineZ = 0.0f;

// âšª NOTE: Current sensor readings
float currentAccelX = 0.0f;
float currentAccelY = 0.0f;
float currentAccelZ = 0.0f;

// âšª NOTE: Configuration values
float motionThreshold = ACCEL_THRESHOLD_DEFAULT;
unsigned long debounceDelay = SENSOR_DEBOUNCE_MS;

// âšª NOTE: Timing for debounce logic
unsigned long lastMotionTime = 0;

// âšª NOTE: Bottom sensor state and debouncing
bool bottomSensorTriggered = false;
bool lastBottomSensorState = false;
unsigned long lastBottomSensorChange = 0;
const unsigned long BOTTOM_SENSOR_DEBOUNCE_MS = 50; // 50ms debounce for digital input

// âšª NOTE: Installation mode flags (not stored in EEPROM)
bool bottomSensorInstallMode = false;
bool motionInstallMode = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Sensor Initialization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool initSensors()
{
#ifdef DEBUG
  Serial.println(F("Sensors: Initializing..."));
#endif

  // ğŸ”µ INFO: Initialize MPU6050 accelerometer
  // âšª NOTE: I2C (Wire) must already be initialized in main.cpp
  byte status = mpu.begin();

  // ğŸ”µ INFO: Verify connection to MPU6050
  if (status != 0)
  {
#ifdef DEBUG
    Serial.print(F("Sensors: ERROR - MPU6050 connection failed, status: "));
    Serial.println(status);
#endif
    return false;
  }

#ifdef DEBUG
  Serial.println(F("Sensors: MPU6050 initialized successfully"));
#endif

  // ğŸ”µ INFO: Configure bottom sensor digital input
  // âšª NOTE: INPUT_PULLUP provides stable readings without external resistor
  pinMode(PIN_BOTTOM_SENSOR, INPUT_PULLUP);

#ifdef DEBUG
  Serial.println(F("Sensors: Bottom sensor pin configured"));
#endif

// ğŸ”µ INFO: Perform initial calibration
// âšª NOTE: Establishes baseline for motion detection
#ifdef DEBUG
  Serial.println(F("Sensors: Starting calibration (keep still for 3 seconds)..."));
#endif

  delay(1000);
  mpu.calcOffsets(); // Built-in calibration function

  delay(100); // Allow sensor to stabilize
  calibrateMPU6050();

  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: MPU6050 Calibration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void calibrateMPU6050()
{
#ifdef DEBUG
  Serial.println(F("Sensors: Recording baseline readings..."));
#endif

  // ğŸ”µ INFO: Take multiple readings and average for stable baseline
  // âšª NOTE: 20 samples provides good accuracy without excessive delay
  constexpr uint8_t numSamples = 20;
  float sumX = 0;
  float sumY = 0;
  float sumZ = 0;

  for (uint8_t i = 0; i < numSamples; i++)
  {
    mpu.update();

    sumX += mpu.getAccX();
    sumY += mpu.getAccY();
    sumZ += mpu.getAccZ();

    delay(10); // 10ms between samples
  }

  // ğŸ”µ INFO: Calculate baseline average
  // âšª NOTE: MPU6050_light library returns values in g units
  constexpr float gravity = 9.81f; // m/sÂ²

  accelBaselineX = (sumX / (float)numSamples) * gravity;
  accelBaselineY = (sumY / (float)numSamples) * gravity;
  accelBaselineZ = (sumZ / (float)numSamples) * gravity;

#ifdef DEBUG
  Serial.println(F("Sensors: Calibration complete"));
  Serial.print(F("  - Baseline X: "));
  Serial.print(accelBaselineX, 2);
  Serial.println(F(" m/sÂ²"));
  Serial.print(F("  - Baseline Y: "));
  Serial.print(accelBaselineY, 2);
  Serial.println(F(" m/sÂ²"));
  Serial.print(F("  - Baseline Z: "));
  Serial.print(accelBaselineZ, 2);
  Serial.println(F(" m/sÂ²"));
#endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Sensor Readings
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateSensors()
{
  // ğŸ”µ INFO: Update MPU6050 readings
  mpu.update();

  // ğŸ”µ INFO: Read accelerometer data (values in g units)
  // âšª NOTE: Convert to m/sÂ² by multiplying with gravity
  constexpr float gravity = 9.81f;

  currentAccelX = mpu.getAccX() * gravity;
  currentAccelY = mpu.getAccY() * gravity;
  currentAccelZ = mpu.getAccZ() * gravity;

  // ğŸ”µ INFO: Read bottom sensor with debouncing
  // âšª NOTE: LOW = triggered (object detected), HIGH = no detection
  bool currentSensorState = (digitalRead(PIN_BOTTOM_SENSOR) == LOW);

  // ğŸ”µ INFO: Debounce logic - only accept state changes after stable period
  unsigned long currentTime = millis();

  if (currentSensorState != lastBottomSensorState)
  {
    // State changed - reset debounce timer
    lastBottomSensorChange = currentTime;
    lastBottomSensorState = currentSensorState;
  }
  else if (currentTime - lastBottomSensorChange >= BOTTOM_SENSOR_DEBOUNCE_MS)
  {
    // State has been stable for debounce period - accept it
    bottomSensorTriggered = currentSensorState;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Motion Detection Logic
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MotionDirection checkMotion()
{
  // ğŸ”µ INFO: Check debounce timeout to prevent rapid re-triggering
  // âšª NOTE: Ignores new triggers within debounce window
  unsigned long currentTime = millis();
  if (currentTime - lastMotionTime < debounceDelay)
  {
    return MotionDirection::NONE;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Check Bottom Sensor (Walk-Up Detection)
  // âšª NOTE: Someone entering from bottom triggers walk-up effect
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  if (bottomSensorTriggered)
  {
#ifdef DEBUG
    Serial.println(F("Sensors: Bottom sensor triggered - WALK_UP"));
#endif

    lastMotionTime = currentTime;
    return MotionDirection::WALK_UP;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Check MPU6050 Motion (Walk-Down Detection)
  // âšª NOTE: Calculate difference from baseline to detect movement
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  float deltaX = abs(currentAccelX - accelBaselineX);
  float deltaY = abs(currentAccelY - accelBaselineY);
  float deltaZ = abs(currentAccelZ - accelBaselineZ);

  // ğŸ”µ INFO: Calculate total motion magnitude
  // âšª NOTE: Using simple sum instead of vector magnitude for speed
  float totalMotion = deltaX + deltaY + deltaZ;

  // ğŸ”µ INFO: Compare against threshold to determine if motion detected
  if (totalMotion > motionThreshold)
  {
#ifdef DEBUG
    Serial.print(F("Sensors: MPU6050 motion detected - WALK_DOWN (magnitude: "));
    Serial.print(totalMotion, 2);
    Serial.println(F(" m/sÂ²)"));
#endif

    lastMotionTime = currentTime;
    return MotionDirection::WALK_DOWN;
  }

  // âšª NOTE: No motion detected on either sensor
  return MotionDirection::NONE;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Configuration Setters
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setAccelThreshold(float threshold)
{
  // ğŸ”µ INFO: Clamp threshold to valid range
  if (threshold < ACCEL_THRESHOLD_MIN)
    threshold = ACCEL_THRESHOLD_MIN;
  if (threshold > ACCEL_THRESHOLD_MAX)
    threshold = ACCEL_THRESHOLD_MAX;

  motionThreshold = threshold;

#ifdef DEBUG
  Serial.print(F("Sensors: Motion threshold set to "));
  Serial.print(motionThreshold, 2);
  Serial.println(F(" m/sÂ²"));
#endif
}

void setDebounceDelay(unsigned long delayMs)
{
  debounceDelay = delayMs;

#ifdef DEBUG
  Serial.print(F("Sensors: Debounce delay set to "));
  Serial.print(debounceDelay);
  Serial.println(F(" ms"));
#endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Status Reporting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SensorStatus getSensorStatus()
{
  SensorStatus status;

  // ğŸ”µ INFO: Fill structure with current readings
  status.accelX = currentAccelX;
  status.accelY = currentAccelY;
  status.accelZ = currentAccelZ;

  // ğŸ”µ INFO: Calculate motion magnitude for display
  float deltaX = abs(currentAccelX - accelBaselineX);
  float deltaY = abs(currentAccelY - accelBaselineY);
  float deltaZ = abs(currentAccelZ - accelBaselineZ);
  status.accelMagnitude = deltaX + deltaY + deltaZ;

  status.bottomSensorActive = bottomSensorTriggered;
  status.motionDetected = (status.accelMagnitude > motionThreshold);
  status.lastTriggerTime = lastMotionTime;

  return status;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Trigger Reset
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void resetLastTrigger()
{
  // ğŸ”µ INFO: Allow immediate re-trigger by clearing timestamp
  // âšª NOTE: Called when lighting effect completes
  lastMotionTime = 0;

#ifdef DEBUG
  Serial.println(F("Sensors: Last trigger timestamp reset"));
#endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Installation Mode Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setBottomSensorInstallMode(bool enabled)
{
  bottomSensorInstallMode = enabled;

#ifdef DEBUG
  Serial.print(F("Sensors: Bottom sensor install mode "));
  Serial.println(enabled ? F("ENABLED") : F("DISABLED"));
#endif
}

void setMotionInstallMode(bool enabled)
{
  motionInstallMode = enabled;

#ifdef DEBUG
  Serial.print(F("Sensors: Motion sensor install mode "));
  Serial.println(enabled ? F("ENABLED") : F("DISABLED"));
#endif
}

bool isBottomSensorInstallMode()
{
  return bottomSensorInstallMode;
}

bool isMotionInstallMode()
{
  return motionInstallMode;
}

uint8_t getMotionStrength()
{
  // ğŸ”µ INFO: Calculate motion magnitude from baseline
  float deltaX = abs(currentAccelX - accelBaselineX);
  float deltaY = abs(currentAccelY - accelBaselineY);
  float deltaZ = abs(currentAccelZ - accelBaselineZ);

  float totalMotion = deltaX + deltaY + deltaZ;

  // ğŸ”µ INFO: Scale to 0-100% range
  // âšª NOTE: Use 5x threshold as maximum for good visual range
  float maxMotion = motionThreshold * 5.0f;
  uint8_t percentage = (uint8_t)((totalMotion / maxMotion) * 100.0f);

  // ğŸ”µ INFO: Clamp to 0-100 range
  if (percentage > 100)
    percentage = 100;

  return percentage;
}
