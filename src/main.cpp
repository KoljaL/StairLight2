// Generated by Copilot
#include <Arduino.h>
#include <Wire.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include "config.h"
#include "storage.h"
#include "sensors.h"
#include "leds.h"
#include "webserver.h"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Global System State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SystemConfig sysConfig;
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, NTP_SERVER, NTP_OFFSET_DEFAULT, NTP_UPDATE_INTERVAL);

// âšª NOTE: Timing for main loop control
unsigned long lastLoopTime = 0;
unsigned long lastStatusTime = 0;

// âšª NOTE: System state flags
bool systemInitialized = false;
bool lightsDisabledBySchedule = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Setup Function - System Initialization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setup()
{
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize Serial Communication
  // âšª NOTE: Used for debugging and system monitoring
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Serial.begin(SERIAL_BAUD_RATE);
  delay(500); // Allow serial to stabilize

  // ğŸ”µ INFO: Disable watchdog to prevent boot loops during init
  ESP.wdtDisable();
  *((volatile uint32_t *)0x60000900) &= ~(1); // Hardware WDT off

#ifdef DEBUG
  Serial.println(F("\n\n"));
  Serial.println(F("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"));
  Serial.println(F("  StairLight System v1.0"));
  Serial.println(F("  ESP8266 Intelligent Stair Lighting"));
  Serial.println(F("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"));
  Serial.println();
#endif

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize Storage and Load Configuration
  // âšª NOTE: Must happen first as other modules need config values
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  Serial.println(F("[1/6] Initializing Storage..."));
#endif

  initStorage();

  // ğŸ”µ INFO: TEMPORARY - Force factory reset to load new WiFi defaults
  // âšª NOTE: Comment out this line after first successful WiFi connection
  // resetToDefaults(sysConfig);
  // saveConfig(sysConfig);
  // Serial.println(F("  -> Factory reset applied - WiFi credentials loaded"));

  bool configLoaded = loadConfig(sysConfig);

  if (!configLoaded)
  {
#ifdef DEBUG
    Serial.println(F("  -> Using default configuration"));
#endif
  }

  // ğŸ”µ INFO: Force debug mode ON (comment out to use EEPROM setting)
  // âšª NOTE: Useful for debugging without accessing web interface
  sysConfig.debugMode = true;

#ifdef DEBUG
  Serial.println(F("  -> Debug mode FORCED ON in code"));
#endif

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize I2C Bus
  // âšª NOTE: Required by both PCA9685 (LEDs) and MPU6050 (sensors)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  Serial.println(F("[2/6] Initializing I2C Bus..."));
#endif

  Wire.begin(PIN_SDA, PIN_SCL);

#ifdef DEBUG
  Serial.println(F("  -> I2C initialized on pins SDA=D2, SCL=D1"));

  // ğŸ”µ INFO: Scan I2C bus for devices
  Serial.println(F("  -> Scanning I2C bus..."));
  byte deviceCount = 0;
  for (byte address = 1; address < 127; address++)
  {
    Wire.beginTransmission(address);
    byte error = Wire.endTransmission();

    if (error == 0)
    {
      Serial.print(F("     Found device at 0x"));
      if (address < 16)
        Serial.print("0");
      Serial.println(address, HEX);
      deviceCount++;
    }
  }

  if (deviceCount == 0)
  {
    Serial.println(F("     WARNING: No I2C devices found!"));
  }
  else
  {
    Serial.print(F("     Total devices found: "));
    Serial.println(deviceCount);
  }
#endif

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize LED System
  // âšª NOTE: PCA9685 PWM driver for LED control
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  Serial.println(F("[3/6] Initializing LED System..."));
#endif

  if (!initLEDs())
  {
#ifdef DEBUG
    Serial.println(F("  -> ERROR: LED initialization failed"));
#endif
    // ğŸŸ  WARNING: System cannot function without LEDs
    while (1)
    {
      delay(1000);
    } // Halt execution
  }

  // ğŸ”µ INFO: Apply global brightness from config
  setGlobalBrightness(sysConfig.globalBrightness);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize Sensor System
  // âšª NOTE: MPU6050 accelerometer and bottom sensor
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  Serial.println(F("[4/6] Initializing Sensors..."));
#endif

  if (!initSensors())
  {
#ifdef DEBUG
    Serial.println(F("  -> ERROR: Sensor initialization failed"));
#endif
    // ğŸŸ  WARNING: System cannot function without sensors
    while (1)
    {
      delay(1000);
    } // Halt execution
  }

  // ğŸ”µ INFO: Apply sensor configuration from EEPROM
  setAccelThreshold(sysConfig.sensor.accelThreshold);
  setDebounceDelay(sysConfig.sensor.debounceDelay);
  setEffectTimeout(sysConfig.sensor.effectTimeout);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize Web Server
  // âšª NOTE: WiFi and HTTP server for configuration interface
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  Serial.println(F("[5/6] Initializing Web Server..."));
#endif

  if (!initWebServer(sysConfig))
  {
#ifdef DEBUG
    Serial.println(F("  -> WARNING: Web server initialization failed"));
    Serial.println(F("  -> Continuing without WiFi..."));
#endif
    // âšª NOTE: System can still function locally without WiFi
  }
  else
  {
#ifdef DEBUG
    Serial.print(F("  -> Access web interface at: http://"));
    Serial.println(getLocalIP());
#endif
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Initialize NTP Time Client
  // âšª NOTE: Required for scheduling feature
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  Serial.println(F("[6/6] Initializing Time Synchronization..."));
#endif

  if (isWiFiConnected() && sysConfig.schedule.enabled)
  {
    timeClient.setTimeOffset(sysConfig.schedule.timezoneOffset);
    timeClient.begin();
    timeClient.update();

#ifdef DEBUG
    Serial.print(F("  -> Current time: "));
    Serial.println(timeClient.getFormattedTime());
#endif
  }
  else
  {
#ifdef DEBUG
    Serial.println(F("  -> Scheduling disabled (no WiFi or disabled in config)"));
#endif
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: System Ready
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  systemInitialized = true;

  // ğŸ”µ INFO: Re-enable watchdog now that init is complete
  ESP.wdtEnable(5000); // 5 second timeout

#ifdef DEBUG
  Serial.println();
  Serial.println(F("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"));
  Serial.println(F("  System Initialized Successfully"));
  Serial.println(F("  Ready for Motion Detection"));
  Serial.println(F("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"));
  Serial.println();
#endif

// ğŸ”µ INFO: Run Knight Rider startup animation
#ifdef DEBUG
  Serial.println(F("  -> Starting Knight Rider animation"));
#endif
  startKnightRider();

  // ğŸ”µ INFO: Wait for Knight Rider to complete
  // âšª NOTE: Provides visual feedback that system is booting
  while (isEffectRunning())
  {
    updateLEDs();
    delay(20);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Check if Lights Should Be Disabled by Schedule
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool checkSchedule()
{
  // ğŸ”µ INFO: Skip check if scheduling disabled
  if (!sysConfig.schedule.enabled)
  {
    return false; // Lights NOT disabled
  }

  // ğŸ”µ INFO: Update time from NTP server
  // âšª NOTE: NTPClient handles update intervals internally
  if (isWiFiConnected())
  {
    timeClient.update();
  }

  // ğŸ”µ INFO: Get current hour (0-23)
  int currentHour = timeClient.getHours();

  // ğŸ”µ INFO: Check if current hour is within disable window
  uint8_t startHour = sysConfig.schedule.disableStart;
  uint8_t endHour = sysConfig.schedule.disableEnd;

  bool disabled = false;

  // âšª NOTE: Handle normal case (e.g., disable 8-20 = 8AM to 8PM)
  // âšª TRICKY: Time range logic handles two cases:
  //    1. Normal case: start < end (e.g., 8-20 means 8am-8pm same day)
  //    2. Wraparound case: start > end (e.g., 20-8 means 8pm today through 8am tomorrow)
  if (startHour < endHour)
  {
    disabled = (currentHour >= startHour && currentHour < endHour);
  }
  // âšª NOTE: Handle wraparound case (e.g., disable 20-8 = 8PM to 8AM next day)
  else if (startHour > endHour)
  {
    disabled = (currentHour >= startHour || currentHour < endHour);
  }
  // âšª NOTE: If startHour == endHour, scheduling effectively disabled (no time range)

  return disabled;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Main Loop Function
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void loop()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Feed watchdog to prevent reset
  ESP.wdtFeed();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Rate Limiting for Main Loop
  // âšª NOTE: Prevents excessive CPU usage while maintaining responsiveness
  // âšª PERFORMANCE: 50ms interval gives 20 Hz update rate - adequate for motion detection.
  //    Higher rates would waste CPU without improving user experience.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  if (currentTime - lastLoopTime < LOOP_UPDATE_INTERVAL)
  {
    delay(10); // Short delay to yield CPU to WiFi stack and background tasks
    return;
  }

  lastLoopTime = currentTime;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Update Web Server
  // âšª NOTE: Handle HTTP requests and OTA updates
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  updateWebServer();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Update LED Animations
  // âšª NOTE: Process current effect frame
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  updateLEDs();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Update Sensor Readings
  // âšª NOTE: Read MPU6050 and bottom sensor
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  updateSensors();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Check Scheduling
  // âšª NOTE: Determine if lights should be disabled by time of day
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  bool wasDisabled = lightsDisabledBySchedule;
  lightsDisabledBySchedule = checkSchedule();

  // ğŸ”µ INFO: Log schedule state changes
  if (lightsDisabledBySchedule != wasDisabled)
  {
#ifdef DEBUG
    if (lightsDisabledBySchedule)
    {
      Serial.println(F("Schedule: Lights DISABLED by schedule"));
    }
    else
    {
      Serial.println(F("Schedule: Lights ENABLED by schedule"));
    }
#endif
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Motion Detection and Effect Triggering
  // âšª NOTE: Only process motion if lights not disabled and no effect running
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // ğŸ”µ INFO: Check if installation mode is active
  // âšª NOTE: Installation mode overrides normal motion detection
  if (isBottomSensorInstallMode())
  {
    // ğŸ”µ INFO: Bottom sensor installation mode - light all LEDs when triggered
    SensorStatus sensorStatus = getSensorStatus();
    showBottomSensorInstall(sensorStatus.bottomSensorActive);
  }
  else if (isMotionInstallMode())
  {
    // ğŸ”µ INFO: Motion sensor installation mode - VU meter based on motion strength
    uint8_t strength = getMotionStrength();
    showMotionInstall(strength);
  }
  else if (!lightsDisabledBySchedule && !isEffectRunning())
  {
    MotionDirection motion = checkMotion();

    if (motion != MotionDirection::NONE)
    {
      // ğŸ”µ INFO: Determine which effect to trigger based on motion direction
      if (motion == MotionDirection::WALK_UP)
      {
#ifdef DEBUG
        Serial.println(F("Motion: Walk-up detected, starting walk-up effect"));
#endif

        if (sysConfig.walkUp.enabled)
        {
          startEffect(EffectType::WALK_UP, sysConfig.walkUp);
        }
      }
      else if (motion == MotionDirection::WALK_DOWN)
      {
#ifdef DEBUG
        Serial.println(F("Motion: Walk-down detected, starting walk-down effect"));
#endif

        if (sysConfig.walkDown.enabled)
        {
          startEffect(EffectType::WALK_DOWN, sysConfig.walkDown);
        }
      }
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”µ INFO: Debug Status Output
  // âšª NOTE: Periodic status information when debug mode enabled
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#ifdef DEBUG
  if (sysConfig.debugMode && currentTime - lastStatusTime > STATUS_UPDATE_INTERVAL)
  {
    lastStatusTime = currentTime;

    Serial.println(F("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"));
    Serial.println(F("System Status:"));

    // ğŸ”µ INFO: Sensor status
    SensorStatus sensorStatus = getSensorStatus();
    Serial.print(F("  Accel: X="));
    Serial.print(sensorStatus.accelX, 2);
    Serial.print(F(" Y="));
    Serial.print(sensorStatus.accelY, 2);
    Serial.print(F(" Z="));
    Serial.print(sensorStatus.accelZ, 2);
    Serial.print(F(" Mag="));
    Serial.println(sensorStatus.accelMagnitude, 2);

    Serial.print(F("  Bottom Sensor: "));
    Serial.println(sensorStatus.bottomSensorActive ? "ACTIVE" : "Inactive");

    Serial.print(F("  Motion Detected: "));
    Serial.println(sensorStatus.motionDetected ? "YES" : "No");

    // ğŸ”µ INFO: Effect status
    Serial.print(F("  Effect Running: "));
    Serial.println(isEffectRunning() ? "YES" : "No");

    Serial.print(F("  Current State: "));
    Serial.println((uint8_t)getCurrentState());

    // ğŸ”µ INFO: WiFi status
    Serial.print(F("  WiFi: "));
    Serial.println(getWebServerStatus());

    // ğŸ”µ INFO: Schedule status
    Serial.print(F("  Lights: "));
    Serial.println(lightsDisabledBySchedule ? "DISABLED by schedule" : "Enabled");

    // ğŸ”µ INFO: Memory status
    Serial.print(F("  Free Heap: "));
    Serial.print(ESP.getFreeHeap());
    Serial.println(F(" bytes"));

    Serial.println(F("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"));
  }
#endif
}
