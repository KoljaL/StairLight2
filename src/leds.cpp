// Generated by Copilot
#include "leds.h"
#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Global LED Objects and State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(PCA9685_ADDRESS);

// âšª NOTE: Current effect state and configuration
EffectState currentState = EffectState::IDLE;
EffectType activeEffectType = EffectType::WALK_UP;
EffectConfig activeConfig;

// âšª NOTE: Effect timing variables
unsigned long effectStartTime = 0;
unsigned long lastStepTime = 0;
unsigned long holdStartTime = 0;
unsigned long effectTimeout = EFFECT_TIMEOUT_DEFAULT;

// âšª NOTE: Animation progress tracking
uint8_t currentStep = 0;
uint8_t globalBrightness = BRIGHTNESS_DEFAULT;

// âšª NOTE: Individual LED brightness targets and current values
uint16_t targetBrightness[LED_COUNT] = {0};
uint16_t currentBrightness[LED_COUNT] = {0};

// âšª NOTE: Knight Rider effect variables
bool knightRiderDirection = true; // true = forward, false = backward
uint8_t knightRiderPosition = 0;
uint8_t knightRiderBounces = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Gamma Correction Lookup Table
// âšª NOTE: Provides perceptually linear brightness for human eyes
// âšª NOTE: Maps 0-255 input to 0-4095 output (12-bit PWM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const uint16_t PROGMEM gammaTable[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 9, 10, 11,
    12, 13, 15, 16, 17, 18, 20, 21, 23, 25, 26, 28, 30, 32, 34, 36,
    38, 40, 43, 45, 48, 50, 53, 56, 59, 62, 65, 68, 71, 75, 78, 82,
    85, 89, 93, 97, 101, 105, 110, 114, 119, 123, 128, 133, 138, 143, 149, 154,
    159, 165, 171, 177, 183, 189, 195, 202, 208, 215, 222, 229, 236, 243, 250, 258,
    266, 273, 281, 290, 298, 306, 315, 324, 332, 341, 351, 360, 369, 379, 389, 399,
    409, 419, 430, 440, 451, 462, 473, 485, 496, 508, 520, 532, 544, 556, 569, 582,
    594, 608, 621, 634, 648, 662, 676, 690, 704, 719, 734, 749, 764, 779, 795, 811,
    827, 843, 859, 876, 893, 910, 927, 944, 962, 980, 998, 1016, 1034, 1053, 1072, 1091,
    1110, 1130, 1150, 1170, 1190, 1210, 1231, 1252, 1273, 1294, 1316, 1338, 1360, 1382, 1404, 1427,
    1450, 1473, 1497, 1520, 1544, 1568, 1593, 1617, 1642, 1667, 1693, 1718, 1744, 1770, 1797, 1823,
    1850, 1877, 1905, 1932, 1960, 1988, 2017, 2045, 2074, 2103, 2133, 2162, 2192, 2223, 2253, 2284,
    2315, 2346, 2378, 2410, 2442, 2474, 2507, 2540, 2573, 2606, 2640, 2674, 2708, 2743, 2778, 2813,
    2849, 2884, 2920, 2957, 2993, 3030, 3067, 3105, 3143, 3181, 3219, 3258, 3297, 3336, 3376, 3416,
    3456, 3496, 3537, 3578, 3619, 3661, 3703, 3745, 3788, 3831, 3874, 3918, 3962, 4006, 4050, 4095};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Helper Function - Apply Gamma Correction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

uint16_t applyGamma(uint8_t brightness)
{
  // ğŸ”µ INFO: Apply global brightness multiplier
  // âšª NOTE: Scale brightness by global percentage
  uint16_t scaled = ((uint16_t)brightness * globalBrightness) / 100;
  if (scaled > 255)
    scaled = 255;

  // ğŸ”µ INFO: Look up gamma-corrected value
  return pgm_read_word(&gammaTable[scaled]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: LED Initialization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool initLEDs()
{
#ifdef DEBUG
  Serial.println(F("LEDs: Initializing PCA9685..."));
#endif

  // ğŸ”µ INFO: Initialize PCA9685 PWM driver
  // âšª NOTE: Wire must already be initialized by sensors module
  pwm.begin();

  // ğŸ”µ INFO: Set PWM frequency for LED control
  // âšª NOTE: 1.6kHz provides flicker-free operation
  pwm.setPWMFreq(PWM_FREQUENCY);

  // ğŸ”µ INFO: Turn off all LEDs initially
  // âšª NOTE: setPWM(channel, 0, 0) = fully off
  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    pwm.setPWM(i, 0, 0);
    targetBrightness[i] = 0;
    currentBrightness[i] = 0;
  }

#ifdef DEBUG
  Serial.println(F("LEDs: PCA9685 initialized, all LEDs off"));
#endif

  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Set Individual LED Brightness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setLED(uint8_t channel, uint8_t brightness)
{
  // ğŸ”µ INFO: Validate channel number
  if (channel >= LED_COUNT)
    return;

  // ğŸ”µ INFO: Apply gamma correction and global brightness
  uint16_t pwmValue = applyGamma(brightness);

  // ğŸ”µ INFO: Update PCA9685 output
  // âšª NOTE: setPWM(channel, onTime, offTime) - use 0 for onTime, pwmValue for offTime
  pwm.setPWM(channel, 0, pwmValue);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Set All LEDs to Same Brightness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setAllLEDs(uint8_t brightness)
{
  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    setLED(i, brightness);
    targetBrightness[i] = brightness;
    currentBrightness[i] = brightness;
  }

#ifdef DEBUG
  Serial.print(F("LEDs: All LEDs set to brightness "));
  Serial.println(brightness);
#endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Smooth Fade Helper Function
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void fadeLED(uint8_t channel, uint8_t targetBright, uint16_t duration)
{
  // ğŸ”µ INFO: Validate channel number
  if (channel >= LED_COUNT)
    return;

  // ğŸ”µ INFO: Calculate steps needed for smooth fade
  // âšª NOTE: Update every 20ms for 50fps animation
  uint16_t steps = duration / 20;
  if (steps == 0)
    steps = 1;

  // âšª NOTE: Store target for completion check
  targetBrightness[channel] = targetBright;

  // ğŸ”µ INFO: For now, just set immediately (smooth fade happens in updateLEDs)
  // âšª NOTE: Full fade implementation would use state machine in updateLEDs()
  // âšª NOTE: Increment calculation removed as it's not yet used
  currentBrightness[channel] = targetBright;
  setLED(channel, targetBright);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Knight Rider Startup Effect
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void startKnightRider()
{
#ifdef DEBUG
  Serial.println(F("LEDs: Starting Knight Rider effect"));
#endif

  currentState = EffectState::KNIGHT_RIDER;
  knightRiderPosition = 0;
  knightRiderDirection = true;
  knightRiderBounces = 0;
  lastStepTime = millis();

  // ğŸ”µ INFO: Turn off all LEDs for clean start
  setAllLEDs(0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Start Main Lighting Effect
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void startEffect(EffectType type, const EffectConfig &config)
{
  // ğŸ”µ INFO: Check if effect is enabled in configuration
  if (!config.enabled)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Effect disabled in config, ignoring"));
#endif
    return;
  }

#ifdef DEBUG
  Serial.print(F("LEDs: Starting effect type "));
  Serial.println((uint8_t)type);
#endif

  activeEffectType = type;
  activeConfig = config;
  currentStep = 0;
  effectStartTime = millis();
  lastStepTime = millis();

  // ğŸ”µ INFO: Determine initial state based on effect type
  switch (type)
  {
  case EffectType::WALK_UP:
    currentState = EffectState::WALK_UP_ON;
    break;

  case EffectType::WALK_DOWN:
    currentState = EffectState::WALK_DOWN_ON;
    break;

  case EffectType::WALK_UP_OUT:
    currentState = EffectState::WALK_UP_OFF;
    break;

  case EffectType::WALK_DOWN_OUT:
    currentState = EffectState::WALK_DOWN_OFF;
    break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Stop All Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void stopAllEffects()
{
#ifdef DEBUG
  Serial.println(F("LEDs: Stopping all effects"));
#endif

  currentState = EffectState::IDLE;
  setAllLEDs(0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Knight Rider Animation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateKnightRider()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next animation step
  if (currentTime - lastStepTime < KNIGHT_RIDER_SPEED)
  {
    return; // Not yet time for next frame
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Turn off all LEDs
  setAllLEDs(0);

  // ğŸ”µ INFO: Light up current position with trail effect
  // âšª NOTE: Creates sweeping light effect with fade trail
  if (knightRiderPosition > 0)
  {
    setLED(knightRiderPosition - 1, 30); // Dim trail
  }
  setLED(knightRiderPosition, 100); // Bright center
  if (knightRiderPosition < LED_COUNT - 1)
  {
    setLED(knightRiderPosition + 1, 30); // Dim trail
  }

  // ğŸ”µ INFO: Move to next position
  if (knightRiderDirection)
  {
    knightRiderPosition++;
    if (knightRiderPosition >= LED_COUNT - 1)
    {
      knightRiderDirection = false; // Bounce back
      knightRiderBounces++;
    }
  }
  else
  {
    knightRiderPosition--;
    if (knightRiderPosition == 0)
    {
      knightRiderDirection = true; // Bounce forward
      knightRiderBounces++;
    }
  }

  // ğŸ”µ INFO: End effect after 4 complete bounces
  // âšª NOTE: 4 bounces = 2 complete back-and-forth cycles
  if (knightRiderBounces >= 4)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Knight Rider effect complete"));
#endif
    stopAllEffects();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Up Effect (Bottom to Top, Lights ON)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkUpOn()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Light up LEDs from bottom (0) to top (LED_COUNT-1)
  // âšª NOTE: Overlap allows multiple LEDs to light simultaneously
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    fadeLED(currentStep + i, activeConfig.brightness, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are lit
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-up complete, entering HOLD state"));
#endif
    currentState = EffectState::HOLD;
    holdStartTime = millis();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Down Effect (Top to Bottom, Lights ON)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkDownOn()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Light up LEDs from top (LED_COUNT-1) to bottom (0)
  // âšª NOTE: currentStep counts up, but we light from top down
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    uint8_t ledIndex = LED_COUNT - 1 - currentStep - i;
    fadeLED(ledIndex, activeConfig.brightness, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are lit
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-down complete, entering HOLD state"));
#endif
    currentState = EffectState::HOLD;
    holdStartTime = millis();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Up-Out Effect (Bottom to Top, Lights OFF)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkUpOff()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Turn off LEDs from bottom (0) to top (LED_COUNT-1)
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    fadeLED(currentStep + i, 0, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are off
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-up-out complete, entering IDLE"));
#endif
    currentState = EffectState::IDLE;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Down-Out Effect (Top to Bottom, Lights OFF)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkDownOff()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Turn off LEDs from top (LED_COUNT-1) to bottom (0)
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    uint8_t ledIndex = LED_COUNT - 1 - currentStep - i;
    fadeLED(ledIndex, 0, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are off
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-down-out complete, entering IDLE"));
#endif
    currentState = EffectState::IDLE;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Hold State (Wait for Timeout)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateHold()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if hold timeout expired
  if (currentTime - holdStartTime >= effectTimeout)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Hold timeout, starting fade-out"));
#endif

    // ğŸ”µ INFO: Determine fade-out direction based on original effect
    // âšª NOTE: Walk-up lights should walk-up-out, walk-down should walk-down-out
    currentStep = 0;
    lastStepTime = millis();

    if (activeEffectType == EffectType::WALK_UP)
    {
      currentState = EffectState::WALK_UP_OFF;
    }
    else
    {
      currentState = EffectState::WALK_DOWN_OFF;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Main LED Update Function
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateLEDs()
{
  // ğŸ”µ INFO: Dispatch to appropriate update function based on state
  switch (currentState)
  {
  case EffectState::IDLE:
    // âšª NOTE: Nothing to do when idle
    break;

  case EffectState::KNIGHT_RIDER:
    updateKnightRider();
    break;

  case EffectState::WALK_UP_ON:
    updateWalkUpOn();
    break;

  case EffectState::WALK_DOWN_ON:
    updateWalkDownOn();
    break;

  case EffectState::HOLD:
    updateHold();
    break;

  case EffectState::WALK_UP_OFF:
    updateWalkUpOff();
    break;

  case EffectState::WALK_DOWN_OFF:
    updateWalkDownOff();
    break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Configuration Setters
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setGlobalBrightness(uint8_t brightness)
{
  // ğŸ”µ INFO: Clamp to valid range
  if (brightness < BRIGHTNESS_MIN)
    brightness = BRIGHTNESS_MIN;
  if (brightness > BRIGHTNESS_MAX)
    brightness = BRIGHTNESS_MAX;

  globalBrightness = brightness;

#ifdef DEBUG
  Serial.print(F("LEDs: Global brightness set to "));
  Serial.print(globalBrightness);
  Serial.println(F("%"));
#endif
}

void setEffectTimeout(unsigned long timeoutMs)
{
  effectTimeout = timeoutMs;

#ifdef DEBUG
  Serial.print(F("LEDs: Effect timeout set to "));
  Serial.print(effectTimeout);
  Serial.println(F(" ms"));
#endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: State Query Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool isEffectRunning()
{
  return currentState != EffectState::IDLE;
}

EffectState getCurrentState()
{
  return currentState;
}
