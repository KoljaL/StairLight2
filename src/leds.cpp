// Generated by Copilot
#include "leds.h"
#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Global LED Objects and State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(PCA9685_ADDRESS);

// âšª NOTE: Current effect state and configuration
EffectState currentState = EffectState::IDLE;
EffectType activeEffectType = EffectType::WALK_UP;
EffectConfig activeConfig;

// âšª NOTE: Effect timing variables
unsigned long effectStartTime = 0;
unsigned long lastStepTime = 0;
unsigned long holdStartTime = 0;
unsigned long effectTimeout = EFFECT_TIMEOUT_DEFAULT;

// âšª NOTE: Animation progress tracking
uint8_t currentStep = 0;
uint8_t globalBrightness = BRIGHTNESS_DEFAULT;

// âšª NOTE: Individual LED brightness targets and current values
uint16_t targetBrightness[LED_COUNT] = {0};
uint16_t currentBrightness[LED_COUNT] = {0};

// âšª NOTE: Fade tracking for smooth transitions
unsigned long fadeStartTime[LED_COUNT] = {0};
uint16_t fadeStartBrightness[LED_COUNT] = {0};
uint16_t fadeDuration[LED_COUNT] = {0};
bool isFading[LED_COUNT] = {false};

// âšª NOTE: Knight Rider effect variables
bool knightRiderDirection = true; // true = forward, false = backward
uint8_t knightRiderPosition = 0;
uint8_t knightRiderBounces = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Gamma Correction Lookup Table
// âšª NOTE: Provides perceptually linear brightness for human eyes
// âšª NOTE: Maps 0-255 input to 0-4095 output (12-bit PWM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const uint16_t PROGMEM gammaTable[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 9, 10, 11,
    12, 13, 15, 16, 17, 18, 20, 21, 23, 25, 26, 28, 30, 32, 34, 36,
    38, 40, 43, 45, 48, 50, 53, 56, 59, 62, 65, 68, 71, 75, 78, 82,
    85, 89, 93, 97, 101, 105, 110, 114, 119, 123, 128, 133, 138, 143, 149, 154,
    159, 165, 171, 177, 183, 189, 195, 202, 208, 215, 222, 229, 236, 243, 250, 258,
    266, 273, 281, 290, 298, 306, 315, 324, 332, 341, 351, 360, 369, 379, 389, 399,
    409, 419, 430, 440, 451, 462, 473, 485, 496, 508, 520, 532, 544, 556, 569, 582,
    594, 608, 621, 634, 648, 662, 676, 690, 704, 719, 734, 749, 764, 779, 795, 811,
    827, 843, 859, 876, 893, 910, 927, 944, 962, 980, 998, 1016, 1034, 1053, 1072, 1091,
    1110, 1130, 1150, 1170, 1190, 1210, 1231, 1252, 1273, 1294, 1316, 1338, 1360, 1382, 1404, 1427,
    1450, 1473, 1497, 1520, 1544, 1568, 1593, 1617, 1642, 1667, 1693, 1718, 1744, 1770, 1797, 1823,
    1850, 1877, 1905, 1932, 1960, 1988, 2017, 2045, 2074, 2103, 2133, 2162, 2192, 2223, 2253, 2284,
    2315, 2346, 2378, 2410, 2442, 2474, 2507, 2540, 2573, 2606, 2640, 2674, 2708, 2743, 2778, 2813,
    2849, 2884, 2920, 2957, 2993, 3030, 3067, 3105, 3143, 3181, 3219, 3258, 3297, 3336, 3376, 3416,
    3456, 3496, 3537, 3578, 3619, 3661, 3703, 3745, 3788, 3831, 3874, 3918, 3962, 4006, 4050, 4095};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Helper Function - Apply Gamma Correction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

uint16_t applyGamma(uint8_t brightness)
{
  // ğŸ”µ INFO: Apply global brightness multiplier
  // âšª NOTE: Scale brightness by global percentage
  uint16_t scaled = ((uint16_t)brightness * globalBrightness) / 100;
  if (scaled > 255)
    scaled = 255;

  // ğŸ”µ INFO: Look up gamma-corrected value
  return pgm_read_word(&gammaTable[scaled]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: LED Initialization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool initLEDs()
{
#ifdef DEBUG
  Serial.println(F("LEDs: Initializing PCA9685..."));
#endif

  // ğŸ”µ INFO: Initialize PCA9685 PWM driver
  // âšª NOTE: Wire must already be initialized by sensors module
  pwm.begin();

  // ğŸ”µ INFO: Set PWM frequency for LED control
  // âšª NOTE: 1.6kHz provides flicker-free operation
  pwm.setPWMFreq(PWM_FREQUENCY);

  // ğŸ”µ INFO: Turn off all LEDs initially
  // âšª NOTE: setPWM(channel, 0, 0) = fully off
  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    pwm.setPWM(i, 0, 0);
    targetBrightness[i] = 0;
    currentBrightness[i] = 0;
  }

#ifdef DEBUG
  Serial.println(F("LEDs: PCA9685 initialized, all LEDs off"));
#endif

  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Set Individual LED Brightness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setLED(uint8_t channel, uint8_t brightness)
{
  // ğŸ”µ INFO: Validate channel number
  if (channel >= LED_COUNT)
    return;

  // ğŸ”µ INFO: Apply gamma correction and global brightness
  uint16_t pwmValue = applyGamma(brightness);

  // ğŸ”µ INFO: Update PCA9685 output
  // âšª NOTE: setPWM(channel, onTime, offTime) - use 0 for onTime, pwmValue for offTime
  pwm.setPWM(channel, 0, pwmValue);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Set All LEDs to Same Brightness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setAllLEDs(uint8_t brightness)
{
  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    setLED(i, brightness);
    targetBrightness[i] = brightness;
    currentBrightness[i] = brightness;
  }

  // #ifdef DEBUG
  //   Serial.print(F("LEDs: All LEDs set to brightness "));
  //   Serial.println(brightness);
  // #endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Smooth Fade Helper Function
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void fadeLED(uint8_t channel, uint8_t targetBright, uint16_t duration)
{
  // ğŸ”µ INFO: Validate channel number
  if (channel >= LED_COUNT)
    return;

  // ğŸ”µ INFO: If duration is 0 or very short, set immediately
  if (duration < 20)
  {
    currentBrightness[channel] = targetBright;
    targetBrightness[channel] = targetBright;
    isFading[channel] = false;
    setLED(channel, targetBright);
    return;
  }

  // ğŸ”µ INFO: Initialize fade parameters
  fadeStartTime[channel] = millis();
  fadeStartBrightness[channel] = currentBrightness[channel];
  targetBrightness[channel] = targetBright;
  fadeDuration[channel] = duration;
  isFading[channel] = true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Fading LEDs
// âšª NOTE: Process smooth brightness transitions for all LEDs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateFades()
{
  unsigned long currentTime = millis();

  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    // Skip LEDs that aren't fading
    if (!isFading[i])
      continue;

    // Calculate elapsed time since fade started
    unsigned long elapsed = currentTime - fadeStartTime[i];

    // Check if fade is complete
    if (elapsed >= fadeDuration[i])
    {
      currentBrightness[i] = targetBrightness[i];
      isFading[i] = false;
      setLED(i, targetBrightness[i]);
    }
    else
    {
      // Calculate current brightness using linear interpolation
      int16_t startBright = fadeStartBrightness[i];
      int16_t endBright = targetBrightness[i];
      int16_t delta = endBright - startBright;

      // Apply fade progress (0.0 to 1.0)
      int16_t newBrightness = startBright + ((delta * (int32_t)elapsed) / fadeDuration[i]);

      // Clamp to valid range
      if (newBrightness < 0)
        newBrightness = 0;
      if (newBrightness > 255)
        newBrightness = 255;

      // ğŸ”µ INFO: Only update if brightness changed to reduce PWM updates
      // âšª NOTE: This prevents flicker from unnecessary rapid updates
      if (newBrightness != currentBrightness[i])
      {
        currentBrightness[i] = newBrightness;
        setLED(i, newBrightness);
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Knight Rider Startup Effect
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void startKnightRider()
{
#ifdef DEBUG
  Serial.println(F("LEDs: Starting Knight Rider effect"));
#endif

  currentState = EffectState::KNIGHT_RIDER;
  knightRiderPosition = 0;
  knightRiderDirection = true;
  knightRiderBounces = 0;
  lastStepTime = millis();

  // ğŸ”µ INFO: Turn off all LEDs for clean start
  setAllLEDs(0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Start Main Lighting Effect
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void startEffect(EffectType type, const EffectConfig &config)
{
  // ğŸ”µ INFO: Check if effect is enabled in configuration
  if (!config.enabled)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Effect disabled in config, ignoring"));
#endif
    return;
  }

#ifdef DEBUG
  Serial.print(F("LEDs: Starting effect type "));
  Serial.println((uint8_t)type);
#endif

  activeEffectType = type;
  activeConfig = config;
  currentStep = 0;
  effectStartTime = millis();
  lastStepTime = millis();

  // ğŸ”µ INFO: Determine initial state based on effect type
  switch (type)
  {
  case EffectType::WALK_UP:
    currentState = EffectState::WALK_UP_ON;
    break;

  case EffectType::WALK_DOWN:
    currentState = EffectState::WALK_DOWN_ON;
    break;

  case EffectType::WALK_UP_OUT:
    currentState = EffectState::WALK_UP_OFF;
    break;

  case EffectType::WALK_DOWN_OUT:
    currentState = EffectState::WALK_DOWN_OFF;
    break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Stop All Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void stopAllEffects()
{
#ifdef DEBUG
  Serial.println(F("LEDs: Stopping all effects"));
#endif

  currentState = EffectState::IDLE;
  setAllLEDs(0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Knight Rider Animation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateKnightRider()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next animation step
  if (currentTime - lastStepTime < KNIGHT_RIDER_SPEED)
  {
    return; // Not yet time for next frame
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Turn off all LEDs
  setAllLEDs(0);

  // ğŸ”µ INFO: Light up current position with 3-LED window effect
  // âšª NOTE: Center LED at 100%, side LEDs at 25% (adapted from Knight Rider example)

  // Handle edge case: position 0 (bottom)
  if (knightRiderPosition == 0)
  {
    setLED(knightRiderPosition, 100);    // Center at 100%
    setLED(knightRiderPosition + 1, 25); // Side at 25%
  }
  // Handle edge case: last position (top)
  else if (knightRiderPosition == LED_COUNT - 1)
  {
    setLED(knightRiderPosition - 1, 25); // Side at 25%
    setLED(knightRiderPosition, 100);    // Center at 100%
  }
  // Normal case: middle positions
  else
  {
    setLED(knightRiderPosition - 1, 25); // Left side at 25%
    setLED(knightRiderPosition, 100);    // Center at 100%
    setLED(knightRiderPosition + 1, 25); // Right side at 25%
  }

  // ğŸ”µ INFO: Move to next position
  if (knightRiderDirection)
  {
    knightRiderPosition++;
    if (knightRiderPosition >= LED_COUNT - 1)
    {
      knightRiderDirection = false; // Bounce back
      knightRiderBounces++;
    }
  }
  else
  {
    knightRiderPosition--;
    if (knightRiderPosition == 0)
    {
      knightRiderDirection = true; // Bounce forward
      knightRiderBounces++;
    }
  }

  // ğŸ”µ INFO: End effect after 4 complete bounces
  // âšª NOTE: 4 bounces = 2 complete back-and-forth cycles
  if (knightRiderBounces >= 4)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Knight Rider effect complete"));
#endif
    stopAllEffects();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Up Effect (Bottom to Top, Lights ON)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkUpOn()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Light up LEDs from bottom (0) to top (LED_COUNT-1)
  // âšª NOTE: Overlap allows multiple LEDs to light simultaneously
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    fadeLED(currentStep + i, activeConfig.brightness, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are lit
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-up complete, entering HOLD state"));
#endif
    currentState = EffectState::HOLD;
    holdStartTime = millis();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Down Effect (Top to Bottom, Lights ON)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkDownOn()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Light up LEDs from top (LED_COUNT-1) to bottom (0)
  // âšª NOTE: currentStep counts up, but we light from top down
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    uint8_t ledIndex = LED_COUNT - 1 - currentStep - i;
    fadeLED(ledIndex, activeConfig.brightness, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are lit
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-down complete, entering HOLD state"));
#endif
    currentState = EffectState::HOLD;
    holdStartTime = millis();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Up-Out Effect (Bottom to Top, Lights OFF)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkUpOff()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Turn off LEDs from bottom (0) to top (LED_COUNT-1)
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    fadeLED(currentStep + i, 0, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are off
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-up-out complete, entering IDLE"));
#endif
    currentState = EffectState::IDLE;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Walk-Down-Out Effect (Top to Bottom, Lights OFF)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateWalkDownOff()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if time for next step
  if (currentTime - lastStepTime < activeConfig.stepDelay)
  {
    return;
  }

  lastStepTime = currentTime;

  // ğŸ”µ INFO: Turn off LEDs from top (LED_COUNT-1) to bottom (0)
  for (uint8_t i = 0; i < activeConfig.overlap && (currentStep + i) < LED_COUNT; i++)
  {
    uint8_t ledIndex = LED_COUNT - 1 - currentStep - i;
    fadeLED(ledIndex, 0, activeConfig.fadeDuration);
  }

  currentStep++;

  // ğŸ”µ INFO: Check if all LEDs are off
  if (currentStep >= LED_COUNT)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Walk-down-out complete, entering IDLE"));
#endif
    currentState = EffectState::IDLE;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Update Hold State (Wait for Timeout)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateHold()
{
  unsigned long currentTime = millis();

  // ğŸ”µ INFO: Check if hold timeout expired
  if (currentTime - holdStartTime >= effectTimeout)
  {
#ifdef DEBUG
    Serial.println(F("LEDs: Hold timeout, starting fade-out"));
#endif

    // ğŸ”µ INFO: Determine fade-out direction based on original effect
    // âšª NOTE: Walk-up lights should walk-up-out, walk-down should walk-down-out
    currentStep = 0;
    lastStepTime = millis();

    if (activeEffectType == EffectType::WALK_UP)
    {
      currentState = EffectState::WALK_UP_OFF;
    }
    else
    {
      currentState = EffectState::WALK_DOWN_OFF;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Main LED Update Function
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void updateLEDs()
{
  // ğŸ”µ INFO: Always update fading LEDs for smooth transitions
  updateFades();

  // ğŸ”µ INFO: Dispatch to appropriate update function based on state
  switch (currentState)
  {
  case EffectState::IDLE:
    // âšª NOTE: Fades can still complete in idle state
    break;

  case EffectState::KNIGHT_RIDER:
    updateKnightRider();
    break;

  case EffectState::WALK_UP_ON:
    updateWalkUpOn();
    break;

  case EffectState::WALK_DOWN_ON:
    updateWalkDownOn();
    break;

  case EffectState::HOLD:
    updateHold();
    break;

  case EffectState::WALK_UP_OFF:
    updateWalkUpOff();
    break;

  case EffectState::WALK_DOWN_OFF:
    updateWalkDownOff();
    break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Configuration Setters
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void setGlobalBrightness(uint8_t brightness)
{
  // ğŸ”µ INFO: Clamp to valid range
  if (brightness < BRIGHTNESS_MIN)
    brightness = BRIGHTNESS_MIN;
  if (brightness > BRIGHTNESS_MAX)
    brightness = BRIGHTNESS_MAX;

  globalBrightness = brightness;

#ifdef DEBUG
  Serial.print(F("LEDs: Global brightness set to "));
  Serial.print(globalBrightness);
  Serial.println(F("%"));
#endif
}

void setEffectTimeout(unsigned long timeoutMs)
{
  effectTimeout = timeoutMs;

#ifdef DEBUG
  Serial.print(F("LEDs: Effect timeout set to "));
  Serial.print(effectTimeout);
  Serial.println(F(" ms"));
#endif
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: State Query Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool isEffectRunning()
{
  return currentState != EffectState::IDLE;
}

EffectState getCurrentState()
{
  return currentState;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ INFO: Installation Mode LED Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void showBottomSensorInstall(bool triggered)
{
  // ğŸ”µ INFO: Turn all LEDs on when sensor triggered, off otherwise
  // âšª NOTE: Provides immediate visual feedback for sensor testing
  uint8_t brightness = triggered ? 255 : 0;

  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    uint16_t pwmValue = applyGamma(brightness);
    pwm.setPWM(i, 0, pwmValue);
  }
}

void showMotionInstall(uint8_t strength)
{
  // ğŸ”µ INFO: VU meter effect - light up LEDs based on motion strength
  // âšª NOTE: 0% = all off, 100% = all on
  // âšª NOTE: Like an audio level meter on mixing console

  // ğŸ”µ INFO: Calculate how many LEDs to light up
  uint8_t numLEDs = (strength * LED_COUNT) / 100;

  // ğŸ”µ INFO: Light up bottom LEDs proportionally to strength
  for (uint8_t i = 0; i < LED_COUNT; i++)
  {
    uint8_t brightness;

    if (i < numLEDs)
    {
      // ğŸ”µ INFO: Full brightness for LEDs below threshold
      brightness = 255;
    }
    else if (i == numLEDs && numLEDs < LED_COUNT)
    {
      // ğŸ”µ INFO: Partial brightness for transition LED (smooth gradient)
      uint8_t remainder = (strength * LED_COUNT) % 100;
      brightness = (remainder * 255) / 100;
    }
    else
    {
      // ğŸ”µ INFO: Off for LEDs above threshold
      brightness = 0;
    }

    uint16_t pwmValue = applyGamma(brightness);
    pwm.setPWM(i, 0, pwmValue);
  }
}
